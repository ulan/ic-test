// This is an experimental feature used to generate Rust bindings from Candid.
// THIS IS A GENERATED FILE. DO NOT EDIT THIS FILE TO AVOID DATA LOSS.
#![allow(dead_code, unused_imports, non_snake_case)]
use candid::{self, CandidType, Deserialize, Principal, Encode, Decode};

#[derive(CandidType, Deserialize)]
pub enum EcdsaCurve { #[serde(rename="secp256k1")] Secp256K1 }

#[derive(CandidType, Deserialize)]
pub struct EcdsaKeyId { pub name: String, pub curve: EcdsaCurve }

#[derive(CandidType, Deserialize)]
pub enum L2MainnetService { Alchemy, BlockPi, PublicNode, Ankr }

#[derive(CandidType, Deserialize)]
pub struct HttpHeader { pub value: String, pub name: String }

#[derive(CandidType, Deserialize)]
pub struct RpcApi { pub url: String, pub headers: Option<Vec<HttpHeader>> }

#[derive(CandidType, Deserialize)]
pub enum EthMainnetService { Alchemy, BlockPi, Cloudflare, PublicNode, Ankr }

#[derive(CandidType, Deserialize)]
pub enum RpcService {
  EthSepolia(L2MainnetService),
  BaseMainnet(L2MainnetService),
  Custom(RpcApi),
  OptimismMainnet(L2MainnetService),
  ArbitrumOne(L2MainnetService),
  EthMainnet(EthMainnetService),
  Chain(u64),
  Provider(u64),
}

#[derive(CandidType, Deserialize)]
pub struct InitArg {
  pub ecdsa_key_id: EcdsaKeyId,
  pub rpc_service: RpcService,
  pub filter_addresses: Vec<String>,
  pub chain_id: u64,
  pub coprocessor_evm_address: String,
  pub filter_events: Vec<String>,
}

pub struct ServiceName {
  pub canister_id: Principal,
  pub caller: super::Caller
}

impl ServiceName {
  pub fn get_evm_address(&self) -> super::CallBuilder<Option<String>> {
    let args = Encode!();
    self.caller.call(
      self.canister_id, super::CallMode::Query, "get_evm_address", args
    )
  }
}

pub fn new(caller: &super::Caller, canister_id: Principal)-> ServiceName {
  ServiceName { canister_id, caller: caller.clone() }
}

pub fn deploy(
  deployer: &super::Deployer, arg0: InitArg
)-> super::DeployBuilder<ServiceName> 
{
  let args = Encode!(&arg0);
  let result = deployer.deploy(args, new);
  let result = if let Some(id) = canister_id(){
    result.with_canister_id(id)
  }else {result};
  if let Some(wasm) = wasm(){result.with_wasm(wasm)}else {result}
}
pub fn canister_id() -> Option<Principal> { None }

pub fn wasm() -> Option<Vec<u8>> { None }
